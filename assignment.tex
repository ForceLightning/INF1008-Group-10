\documentclass{report}

\input{preamble}
\input{macros}
\input{letterfonts}

\title{\Huge{INF1008}\\Data Structures \& Algorithms}
\author{\huge{Group 10}}
\date{}

\begin{document}

\maketitle
\newpage% or \cleardoublepage
% \pdfbookmark[<level>]{<title>}{<dest>}
\pdfbookmark[section]{\contentsname}{toc}
\tableofcontents
\pagebreak
\chapter{}
\section{Problem Statement}
Implement the queue ADT using a Doubly linked list using any programming language. After the implementation, make use of the standard queue operations to implement the stack ADT. Clearly demonstrate the validity of your implementation through enough test cases. Evaluate the time complexity of the push, pop, empty and full operations.
\section{Requirements/Specification}
Users will have access to a container with behaviour akin to a stack, however in the background, the processes are done using a queue and its functions built upon a linked list structure. Users will have access to the standard stack functions - |push|, |pop|, |isEmpty| and |isFull| operations.
\section{User Guide}
An executable is provided, users can run the executable directly and follow the on screen prompts, more in-depth details are provided in the Testing section.
\section{Structure/Design}
The stack as well as the underlying queue containers both have generic types built into the system. Thus the same code can be re-used to store different types of data, including class objects, should the programmer wish to do that.

There are 3 classes utilised in this program, ``Node'', ``QueueADT'' and ``StackADT''. All 3 classes are template classes using typename |T|.
\subsection{Node}
\begin{figure}[H]
	\caption{Node Class Overview}
	\centering
	\label[fig]{fig:qn1_node}
	\includegraphics[height=0.25\textheight]{qn1_node}
\end{figure}
\begin{itemize}
	\item Data Members
	\begin{enumerate}
		\item |T data| -- Used to store the inputted data
		\item |Node<T>* next| -- Used to store the address of the next node, for use in a linked list
		\item |Node<T>* prev| -- Used to store the address of the previous node, for use in a linked list
	\end{enumerate}
	\item Methods
	\begin{enumerate}
		\item |Node()| -- Default constructor
		\item |~Node()| -- Default destructor
		\item |Node(T data)| -- An overloaded constructor, takes in a variable to initialise the data on construction.
	\end{enumerate}
\end{itemize}
\begin{figure}[H]
	\caption{Queue Class Overview}
	\centering
	\label[fig]{fig:qn1_queue}
	\includegraphics[height=0.25\textheight]{qn1_queue}
\end{figure}
\subsection{QueueADT}
\begin{itemize}
	\item Data Members
	\begin{enumerate}
		\item |int maxSize| -- Used to limit the size of the container
		\item |int currSize| -- Denotes the amount of data stored in the container, will be updated as the data is added and removed from the container
		\item |Node<T>* head| -- A pointer to the head node of the queue
		\item |Node<T>* tail| -- A pointer to the tail node of the queue
	\end{enumerate}
	\item Methods
	\begin{enumerate}
		\item |QueueADT()| -- Default constructor
		\item |~QueueADT()| -- Default destructor, will iterate through the linked list and delete all nodes when called
		\item |QueueADT(int size)| -- An overloaded constructor, takes an int argumnet to initialise |maxSize|
		\item |front()| -- Returns a pointer to the head node of the queue
		\item |back()| -- Returns a pointer to the tail node of the queue
		\item |setMaxSize(int size)| -- Passes in an integer to change the container's max alloted size
		\item |getMaxSize()| -- Returns |maxSize|
		\item |getSize()| -- Returns |currSize|
		\item |isEmpty()| -- Returns the truth value of |if currSize| equal to |0| and if |head| or |tail| are |NULL| as an added precaution, has a time complexity of \(\mathcal{O}(1)\) as |currSize| is updated together with the container, the greater than or equal to comparator is used for added precaution
		\item |push(T data)| -- |data| is passed in, and a |Node| is constructed using its overloaded constructor to be added to the linked list, as well as link the nodes between each other, has a time complexity of \(\mathcal{O}(1)\), as the pointer to the |tail| is stored, new elements can simply be added directly behind |tail| as no comparisons are required. Updates |currSize|, |head|, and |tail| members accordingly
		\item |pop()| -- Removes the element at the front of the queue, and returns a pointer to it to have its data extracted or deleted accordingly, has a time complexity of \(\mathcal{O}(1)\), as a pointer to |head| is stored, thus the front element can be removed directly with no comparisons. Updates |currSize|, |head|, and |tail| members accordingly
		\item |printQueue()| -- Prints the entire linked list, has a time complexity of \(\mathcal{O}(n)\) as iteration through the entire list is required
	\end{enumerate}
\end{itemize}
\subsection{StackADT}
\begin{figure}[H]
	\caption{Stack Class Overview}
	\centering
	\label[fig]{fig:qn1_stack}
	\includegraphics[height=0.25\textheight]{qn1_stack}
\end{figure}
\begin{itemize}
	\item Data Members
	\begin{enumerate}
		\item |QueueADT<T>* queue| -- A pointer to the queue container used to store data
	\end{enumerate}
	\item Methods
	\begin{enumerate}
		\item |StackADT()| -- Default constructor
		\item |~StackADT()| -- Default destructor, invokes the queue destructor, and deletes the pointer to the queue
		\item |StackADT(int size)| -- Overloaded constructor, initialises the |QueueADT| member with a |maxSize| of the value passed in
		\item |setMaxSize(int size)| -- Invokes the |QueueADT| member's |setMaxSize(int size)|, passing the same value in
		\item |getMaxSize()| -- Invokes the |QueueADT| member's |getMaxSize()|
		\item |getSize()| -- Invokes the |QueueADT| member's |getSize()|
		\item |isEmpty()| -- Invokes the |QueueADT| member's |isEmpty()|, therefore time complexity of \(\mathcal{O}(1)\)
		\item |isFull()| -- Invokes the |QueueADT| member's |isFull()|, therefore time complexity of \(\mathcal{O}(1)\)
		\item |push(T data)| -- Invbokes the |QueueADT| member's |push(T data)|, after pushing the initial data in, all the other members in front of it are popped, and re-pushed into the queue to simulate a stack. This causes the function to have a time complexity of \(\mathcal{O}(n)\), as every element in the container has to be reorganised
		\item |pop()| -- Invokes the |QueueADT| member's |pop()|, therefore time complexity of \(\mathcal{O}(1)\)
	\end{enumerate}
\end{itemize}
\section{Limitations}
The data type specified on creation is final and is unable to be changed unless the stack is completely re-initialised. A consideration was made to utilise a class holding multiple data types - |int|(4 bytes), |float|(4 bytes), |double|(8 bytes), |char|(1 byte), |std::string|(\(>24\) bytes) - and construct a container with the type of that class. It would allow the container to store any data that has shares the property of being a standard data type. However upon further deliberation, a class with that many types will cause memory bloat, as an example if the majority of the data entered was integers, for every 4 bytes used, \(>37\) bytes are reserved but unused by the system.
\section{Testing}
Users will be prompted (option 1 or option 2) to either allow the program to automatically generate test cases, or test the system out themselves. Users can also input a ``\$'' to terminate the progam.
\begin{figure}[H]
	\centering
	\caption{Command-line Interface prompt}
	\includegraphics[width=0.8\textwidth]{qn1_input}
	\label{fig:qn1_prompt}
\end{figure}
\subsection{Option 1 -- Automatic Generation}
The program will prompt the user for the type of data they wish to store.
\begin{figure}[H]
	\centering
	\caption{Option 1 prompt}
	\includegraphics[width=0.8\textwidth]{qn1_option1}
	\label{fig:qn1_op1}
\end{figure}
The program will then generate 10 stacks of random length and random amount of data corresponding to the data type specified by the user.

\begin{figure}[H]
	\centering
	\caption{Option 1 testing}
	\includegraphics[width=0.8\textwidth]{qn1_op1_test}
	\label{fig:qn1_op1_test}
\end{figure}
\subsection{Option 2 -- Manual Testing}
The program will similarly prompt the user for the type of data they wish to store. Additionally it will enquire on the size they wish for the container to be.

The user will then be able to enter data fitting to the data type into the stack, any data not fitting the data type will be rejected, discarding it and looping back to where the user can continue inputting data. Similarly, if the user tries to add more data into the stack when it is full, the program will also reject the entry. At any time the user can choose to enter ``\$'' and the process will end, and loop back to the start of the program.

\begin{figure}[H]
	\centering
	\caption{Option 2 testing with invalid inputs}
	\includegraphics[width=0.8\textwidth]{qn1_op2}
	\label{fig:qn1_op2}
\end{figure}
\section{Listings}
\chapter{}
\section{Problem Statement}
Write a program that reads in a sequence of characters, and determines whether its parentheses, braces, and curly braces are ``balanced.'' Your program should read one line of input containing what is supposed to be a properly formed expression in algebra and tells whether it is in fact legal. The expression could have several sets of grouping symbols of various kinds, \(()\), \([]\), and \(\{\}\). Your program needs to make sure that these grouping symbols match up properly. Analyse the efficiency of your implementation and provide a detailed discussion of its time and space complexity.
\section{Requirements/Specification}
Given any algebraic statement, (e.g. \(-b \pm \left[\sqrt{\{b^2\}-(4)(a)(c)}\right]/2(a)\)), determine if the braces are balanced; That is, if the number of opening braces match the number of closing braces, and that the first closing brace matches with the last opening brace. The algorithm expects a properly formed expression in algebra as a string and outputs either |True| or |False|.
\section{User Guide}
To run the program, simply type |python main.py| in a terminal window. The program then prompts the user for an algebraic statement. If the statement is balanced, the program returns |True| and vice versa. No external libraries other than the standard \texttt{Python 3} libraries are required.
\section{Structure/Design}
The algorithm works by pushing opening brackets to a stack by looping through all bracket characters in the original statement. When encountering a closing bracket, it pops the last element of the stack and compares if they are complementary. If at any point the check fails, the algorithm returns |False| and ends the loop prematurely. At the end of the loop, the algorithm checks that the stack is empty. If it is, it returns |True| and |False| otherwise.
\begin{algorithm}[H]
	\KwIn{str statement}
	% \KwIn{Node y}
	% \tcc{x and y are the heads of the two lists}
	% \KwOut{This is some output}
	\SetAlgoLined
	\SetNoFillComment
	% \tcc{This is a comment}
	\vspace{3mm}
	\SetKwProg{Fn}{Function}{ is}{end}
	\SetKw{And}{and}
	\Fn{is\_balanced(statement: str)}{
		statement \(\leftarrow\) all brackets from statement\;
		bracket\_pairings \(\leftarrow\) \{opening\_bracket : closing\_bracket\}\;
		\If{len(statement) \(\mod{2} \ne 0\)}{
			\Return{False}\;
		}
		stack = []\;
		\ForEach{character in statement}{
			\If{character is an opening bracket}{
				stack.push(character)\;
			}
			\ElseIf{bracket\_pairing[stack.pop()] \(\ne\) character}{
				\Return{False}\;
			}
		}
		\Return{len(stack) == 0}\;
	}
	\caption{Bracket balance checker}
\end{algorithm}
As the algorithm iterates through the input string only once, the time complexity is \(\mathcal{O}(n)\) for a given input string of length \(n\). The opening brackets are iteratively pushed to and popped from a stack, so the space complexity is \(\mathcal{O}(n)\) as well.
\nt{The time complexity of \vocab{Regular Expressions} and \vocab{Stack Operations} for insertion and deletion are known to be \(\mathcal{O}(n)\) and \(O(1)\) respectively, so the time and space complexity of the algorithm remains at \(\mathcal{O}(n)\).}
\section{Limitations}
While the algorithm determines perfectly if the brackets within any given algebraic statement are balanced, it does not check if the statement itself is a properly formed algebraic statement. Furthermore, it does not check that brackets on two sides of a given equality are balanced, as it only checks for bracket placement relative to other brackets in the entire input string (i.e. \(([0]\{=\}2)\) will be evaluated as balanced).
\section{Testing}
Testing is handled by the |tests.py| file, which generates \(t\) input strings of up to length \(l\), of which \(\sfrac{n}{2}\) inputs are valid, and the other half are invalid. To generate valid inputs, the generator randomly selects an opening bracket or a closing bracket that matches the last opening bracket until reaching the halfway point of the string length, at which point it iteratively closes all the remaining open brackets. An example output of running the tests is shown in~\autoref{fig:qn2_testing}.
\begin{figure}[H]
	\caption{Test output}
	\centering
	\label[fig]{fig:qn2_testing}
	\includegraphics{Qn2_testing}
\end{figure}
\subsection{Invalid Inputs}
Invalid inputs are a superset of valid inputs, thus the selection of brackets to insert at any given point is expanded to include all invalid closing brackets as well. The generator then selects a random index \(i\) to insert random brackets until the max length is reached. Then, the generator checks if the number of opening brackets match the number of closing brackets for each type of bracket. If they match, a random index is selected again to either insert or remove a bracket. This ensures that we also deal with the case that the length of the input string is odd. The generator then provides the input string and whether the string is valid to a checker function, which compares the output of the developed algorithm with the validity of the input string. To run the tests, a user may run |python test.py --tests \{number of tests\} --length \{max length of input strings\}|. The output will show how many tests the algorithm passes, and what the generated input strings were for each test.
\section{Listings}
\subsection{Algorithm}
\begin{lstlisting}[language=Python]
	import re

	def main(statement:str):
		return is_balanced(statement)

	def is_balanced(statement:str) -> bool:
		bracket_pairing = {
			"{": "}",
			"[": "]",
			"(": ")"
		}
		# fast check
		statement = re.sub(r"[A-Za-z0-9\*\-\+\^\/\=]", "", statement)
		if len(statement) % 2 != 0: return False
		brackets = [bracket for bracket in bracket_pairing.keys()]\
			+ [bracket for bracket in bracket_pairing.values()]
		stack = [ ]
		for char in statement:
			if char in brackets:
				if char in bracket_pairing.keys():
					stack.append(char)
				else:
					try:
						if bracket_pairing[stack.pop()] != char:
							return False
					except IndexError:
						return False
		return len(stack) == 0

	if __name__ == "__main__":
		res = main(input("Enter an algebraic statement: "))
		print(res)
\end{lstlisting}
\subsection{Testing}
\begin{lstlisting}[language=Python]
	import argparse
	import random
	from main import is_balanced

	def test_is_balanced(iters: int, max_length:int=10):
		"""Tests the is_balanced function over a given number of iterations.

		Args:
			iters (int): number of iterations
		"""
		results = []
		for i in range(iters):
			statement, proper = statement_generator(random.randint(1, max_length))
			print(f"Test {i+1}:\t{statement}:", end=" ")
			res = is_balanced(statement)
			if res == proper:
				print(f"Passed ({res})")
			else:
				print(f"Failed: {res} (should be {proper})")
			results.append(res == proper)
		print(f"Passed {results.count(True)} out of {iters} tests")

	def statement_generator(length: int):
		"""Generates a random algebraic statement of a given length.

		Args:
			length (int): length of the statement

		Returns:
			str: random algebraic statement
		"""
		length //= 2
		bracket_pairing = {
			"{": "}",
			"[": "]",
			"(": ")"
		}
		brackets = [bracket for bracket in bracket_pairing.keys()]\
			+ [bracket for bracket in bracket_pairing.values()]
		ret = ""
		state = random.choice([True, False])
		ret += random.choice([bracket for bracket in bracket_pairing.keys()])
		stack = [ret[0]]
		for _ in range(length):
			if state:
				candidates = [b for b in bracket_pairing.keys()]
				if ret[-1] in bracket_pairing.keys():
					candidates += [bracket_pairing[ret[-1]]]
				ret += random.choice(candidates)
				if ret[-1] in bracket_pairing.values():
					stack.pop()
				else:
					stack.append(ret[-1])
			else:
				ret += random.choice(brackets)
		for _ in range(len(stack)):
			if state:
				ret += bracket_pairing[stack.pop()]
			else:
				ret += random.choice(brackets)
		if not state:
			n_additions = random.randint(0, length)
			insertion_index = random.randint(0, len(ret))
			additions = [random.choice(brackets) for _ in range(n_additions)]
			ret = ret[:insertion_index-1] + "".join(additions) + ret[insertion_index+1:len(ret)+1-n_additions]
			# count the number of bracket pairs
			bracket_counts = {(k, v): 0 for k, v in bracket_pairing.items()}
			for char in ret:
				for k, v in bracket_pairing.items():
					if char == k:
						bracket_counts[(k, v)] += 1
					elif char == v:
						bracket_counts[(k, v)] -= 1
			# if the statement is potentially balanced, either remove or add a random character.
			if all([count == 0 for count in bracket_counts.values()]):
				# remove a random character
				if len(ret) > 2:
					loc = random.randint(1, len(ret)-1)
					ret = ret[:loc] + ret[loc+1:]
				else:
					ret += random.choice(brackets)
		return (ret, state)

	def main(tests: int=1000, max_length:int=10):
		test_is_balanced(tests, max_length)

	if __name__ == "__main__":
		parser = argparse.ArgumentParser()
		parser.add_argument("-t", "--tests", type=int, default=1000, help="number of tests to run")
		parser.add_argument("-l", "--length", type=int, default=10, help="maximum length of the statement")
		args = parser.parse_args()
		main(args.tests, args.length)
\end{lstlisting}
\chapter{}
\section{Problem Statement}
\section{Requirements/Specification}
\section{User Guide}
\section{Structure/Design}
\section{Limitations}
\section{Testing}
\section{Listings}
\chapter{}
\section{Problem Statement}
Write a recursive algorithm to check that a sentence is a palindrome (ignoring blanks, lower case and upper case differences, and punctuation marks, so that ``Madam, I'm Adam'' is accepted as a palindrome). Analyse the efficiency of your implementation and provided a detailed discussion of its time complexity.
\ex{}{Please enter a sentence: Madam, I'm Adam Check if ``Madam, I'm Adam'' is a palindrome: True}
\section{Requirements/Specification}
This program is supposed to compare the characters in the sentence. First and last, Second and second last etc. If it matches, it is a palindrome. Some assumptions/conditions would be ignoring blanks, lower case, upper case differences, and punctuation marks. Empty strings will be considered as a palindrome too.
\section{User Guide}
\begin{enumerate}
	\item Click on the ``Run'' button in the IDE to run the program with python. Alternatively, running |python file.py| will run the program.
	\item Input a sentence when prompted in the command line interface.
	\item The resulting output will show whether the input sentence was a palindrome.
\end{enumerate}
\section{Structure/Design}
The design of the system is such that after it recieves an input from the user, it will remove all punctuation and whitespaces in the string, then change all uppercase characters to lowercase characters. The algorithm will then check the first and last characters in the string to see if they match. If they do, the function is recursively called on the manipulated string without the first and last characters. The time complexity of this algorithm is \(\mathcal{O}(n)\).
\section{Limitations}
The algorithm expects only the ASCII character set as input, and may not work on sentences including UTF-8 characters beyond the ASCII character set.
\section{Testing}
\section{Listings}
\chapter{}
\section{Problem Statement}
\section{Requirements/Specification}
\section{User Guide}
\section{Structure/Design}
\section{Limitations}
\section{Testing}
\section{Listings}
\end{document}
