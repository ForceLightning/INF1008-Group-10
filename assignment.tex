\documentclass{report}

\input{preamble}
\input{macros}
\input{letterfonts}

\title{\Huge{INF1008}\\Data Structures \& Algorithms}
\author{\huge{Group 10}}
\date{}

\begin{document}

\maketitle
\newpage% or \cleardoublepage
% \pdfbookmark[<level>]{<title>}{<dest>}
\pdfbookmark[section]{\contentsname}{toc}
\tableofcontents
\pagebreak
\chapter{}
\section{Problem Statement}
Implement the queue ADT using a Doubly linked list using any programming language. After the implementation, make use of the standard queue operations to implement the stack ADT. Clearly demonstrate the validity of your implementation through enough test cases. Evaluate the time complexity of the push, pop, empty and full operations.
\section{Requirements/Specification}
Users will have access to a container with behaviour akin to a stack, however in the background, the processes are done using a queue and its functions built upon a linked list structure. Users will have access to the standard stack functions - |push|, |pop|, |isEmpty| and |isFull| operations.
\section{User Guide}
An executable is provided, users can run the executable directly and follow the on screen prompts, more in-depth details are provided in the Testing section.
\section{Structure/Design}
The stack as well as the underlying queue containers both have generic types built into the system. Thus the same code can be re-used to store different types of data, including class objects, should the programmer wish to do that.

There are 3 classes utilised in this program, ``Node'', ``QueueADT'' and ``StackADT''. All 3 classes are template classes using typename |T|.
\subsection{Node}
\begin{figure}[H]
	\caption{Node Class Overview}
	\centering
	\label[fig]{fig:qn1_node}
	\includegraphics[height=0.25\textheight]{qn1_node}
\end{figure}
\begin{itemize}
	\item Data Members
	\begin{enumerate}
		\item |T data| -- Used to store the inputted data
		\item |Node<T>* next| -- Used to store the address of the next node, for use in a linked list
		\item |Node<T>* prev| -- Used to store the address of the previous node, for use in a linked list
	\end{enumerate}
	\item Methods
	\begin{enumerate}
		\item |Node()| -- Default constructor
		\item |~Node()| -- Default destructor
		\item |Node(T data)| -- An overloaded constructor, takes in a variable to initialise the data on construction.
	\end{enumerate}
\end{itemize}
\begin{figure}[H]
	\caption{Queue Class Overview}
	\centering
	\label[fig]{fig:qn1_queue}
	\includegraphics[height=0.25\textheight]{qn1_queue}
\end{figure}
\subsection{QueueADT}
\begin{itemize}
	\item Data Members
	\begin{enumerate}
		\item |int maxSize| -- Used to limit the size of the container
		\item |int currSize| -- Denotes the amount of data stored in the container, will be updated as the data is added and removed from the container
		\item |Node<T>* head| -- A pointer to the head node of the queue
		\item |Node<T>* tail| -- A pointer to the tail node of the queue
	\end{enumerate}
	\item Methods
	\begin{enumerate}
		\item |QueueADT()| -- Default constructor
		\item |~QueueADT()| -- Default destructor, will iterate through the linked list and delete all nodes when called
		\item |QueueADT(int size)| -- An overloaded constructor, takes an int argumnet to initialise |maxSize|
		\item |front()| -- Returns a pointer to the head node of the queue
		\item |back()| -- Returns a pointer to the tail node of the queue
		\item |setMaxSize(int size)| -- Passes in an integer to change the container's max alloted size
		\item |getMaxSize()| -- Returns |maxSize|
		\item |getSize()| -- Returns |currSize|
		\item |isEmpty()| -- Returns the truth value of |if currSize| equal to |0| and if |head| or |tail| are |NULL| as an added precaution, has a time complexity of \(\mathcal{O}(1)\) as |currSize| is updated together with the container, the greater than or equal to comparator is used for added precaution
		\item |push(T data)| -- |data| is passed in, and a |Node| is constructed using its overloaded constructor to be added to the linked list, as well as link the nodes between each other, has a time complexity of \(\mathcal{O}(1)\), as the pointer to the |tail| is stored, new elements can simply be added directly behind |tail| as no comparisons are required. Updates |currSize|, |head|, and |tail| members accordingly
		\item |pop()| -- Removes the element at the front of the queue, and returns a pointer to it to have its data extracted or deleted accordingly, has a time complexity of \(\mathcal{O}(1)\), as a pointer to |head| is stored, thus the front element can be removed directly with no comparisons. Updates |currSize|, |head|, and |tail| members accordingly
		\item |printQueue()| -- Prints the entire linked list, has a time complexity of \(\mathcal{O}(n)\) as iteration through the entire list is required
	\end{enumerate}
\end{itemize}
\subsection{StackADT}
\begin{figure}[H]
	\caption{Stack Class Overview}
	\centering
	\label[fig]{fig:qn1_stack}
	\includegraphics[height=0.25\textheight]{qn1_stack}
\end{figure}
\begin{itemize}
	\item Data Members
	\begin{enumerate}
		\item |QueueADT<T>* queue| -- A pointer to the queue container used to store data
	\end{enumerate}
	\item Methods
	\begin{enumerate}
		\item |StackADT()| -- Default constructor
		\item |~StackADT()| -- Default destructor, invokes the queue destructor, and deletes the pointer to the queue
		\item |StackADT(int size)| -- Overloaded constructor, initialises the |QueueADT| member with a |maxSize| of the value passed in
		\item |setMaxSize(int size)| -- Invokes the |QueueADT| member's |setMaxSize(int size)|, passing the same value in
		\item |getMaxSize()| -- Invokes the |QueueADT| member's |getMaxSize()|
		\item |getSize()| -- Invokes the |QueueADT| member's |getSize()|
		\item |isEmpty()| -- Invokes the |QueueADT| member's |isEmpty()|, therefore time complexity of \(\mathcal{O}(1)\)
		\item |isFull()| -- Invokes the |QueueADT| member's |isFull()|, therefore time complexity of \(\mathcal{O}(1)\)
		\item |push(T data)| -- Invbokes the |QueueADT| member's |push(T data)|, after pushing the initial data in, all the other members in front of it are popped, and re-pushed into the queue to simulate a stack. This causes the function to have a time complexity of \(\mathcal{O}(n)\), as every element in the container has to be reorganised
		\item |pop()| -- Invokes the |QueueADT| member's |pop()|, therefore time complexity of \(\mathcal{O}(1)\)
	\end{enumerate}
\end{itemize}
\section{Limitations}
The data type specified on creation is final and is unable to be changed unless the stack is completely re-initialised. A consideration was made to utilise a class holding multiple data types - |int|(4 bytes), |float|(4 bytes), |double|(8 bytes), |char|(1 byte), |std::string|(\(>24\) bytes) - and construct a container with the type of that class. It would allow the container to store any data that has shares the property of being a standard data type. However upon further deliberation, a class with that many types will cause memory bloat, as an example if the majority of the data entered was integers, for every 4 bytes used, \(>37\) bytes are reserved but unused by the system.
\section{Testing}
Users will be prompted (option 1 or option 2) to either allow the program to automatically generate test cases, or test the system out themselves. Users can also input a ``\$'' to terminate the progam.
\begin{figure}[H]
	\centering
	\caption{Command-line Interface prompt}
	\includegraphics[width=0.8\textwidth]{qn1_input}
	\label{fig:qn1_prompt}
\end{figure}
\subsection{Option 1 -- Automatic Generation}
The program will prompt the user for the type of data they wish to store.
\begin{figure}[H]
	\centering
	\caption{Option 1 prompt}
	\includegraphics[width=0.8\textwidth]{qn1_option1}
	\label{fig:qn1_op1}
\end{figure}
The program will then generate 10 stacks of random length and random amount of data corresponding to the data type specified by the user.

\begin{figure}[H]
	\centering
	\caption{Option 1 testing}
	\includegraphics[width=0.8\textwidth]{qn1_op1_test}
	\label{fig:qn1_op1_test}
\end{figure}
\subsection{Option 2 -- Manual Testing}
The program will similarly prompt the user for the type of data they wish to store. Additionally it will enquire on the size they wish for the container to be.

The user will then be able to enter data fitting to the data type into the stack, any data not fitting the data type will be rejected, discarding it and looping back to where the user can continue inputting data. Similarly, if the user tries to add more data into the stack when it is full, the program will also reject the entry. At any time the user can choose to enter ``\$'' and the process will end, and loop back to the start of the program.

\begin{figure}[H]
	\centering
	\caption{Option 2 testing with invalid inputs}
	\includegraphics[width=0.8\textwidth]{qn1_op2}
	\label{fig:qn1_op2}
\end{figure}
\section{Listings}
\chapter{}
\section{Problem Statement}
Write a program that reads in a sequence of characters, and determines whether its parentheses, braces, and curly braces are ``balanced.'' Your program should read one line of input containing what is supposed to be a properly formed expression in algebra and tells whether it is in fact legal. The expression could have several sets of grouping symbols of various kinds, \(()\), \([]\), and \(\{\}\). Your program needs to make sure that these grouping symbols match up properly. Analyse the efficiency of your implementation and provide a detailed discussion of its time and space complexity.
\section{Requirements/Specification}
Given any algebraic statement, (e.g. \(-b \pm \left[\sqrt{\{b^2\}-(4)(a)(c)}\right]/2(a)\)), determine if the braces are balanced; That is, if the number of opening braces match the number of closing braces, and that the first closing brace matches with the last opening brace. The algorithm expects a properly formed expression in algebra as a string and outputs either |True| or |False|.
\section{User Guide}
To run the program, simply type |python main.py| in a terminal window. The program then prompts the user for an algebraic statement. If the statement is balanced, the program returns |True| and vice versa. No external libraries other than the standard \texttt{Python 3} libraries are required.
\section{Structure/Design}
The algorithm works by pushing opening brackets to a stack by looping through all bracket characters in the original statement. When encountering a closing bracket, it pops the last element of the stack and compares if they are complementary. If at any point the check fails, the algorithm returns |False| and ends the loop prematurely. At the end of the loop, the algorithm checks that the stack is empty. If it is, it returns |True| and |False| otherwise.
\begin{algorithm}[H]
	\KwIn{str statement}
	% \KwIn{Node y}
	% \tcc{x and y are the heads of the two lists}
	% \KwOut{This is some output}
	\SetAlgoLined
	\SetNoFillComment
	% \tcc{This is a comment}
	\vspace{3mm}
	\SetKwProg{Fn}{Function}{ is}{end}
	\SetKw{And}{and}
	\Fn{is\_balanced(statement: str)}{
		statement \(\leftarrow\) all brackets from statement\;
		bracket\_pairings \(\leftarrow\) \{opening\_bracket : closing\_bracket\}\;
		\If{len(statement) \(\mod{2} \ne 0\)}{
			\Return{False}\;
		}
		stack = []\;
		\ForEach{character in statement}{
			\If{character is an opening bracket}{
				stack.push(character)\;
			}
			\ElseIf{bracket\_pairing[stack.pop()] \(\ne\) character}{
				\Return{False}\;
			}
		}
		\Return{len(stack) == 0}\;
	}
	\caption{Bracket balance checker}
\end{algorithm}
As the algorithm iterates through the input string only once, the time complexity is \(\mathcal{O}(n)\) for a given input string of length \(n\). The opening brackets are iteratively pushed to and popped from a stack, so the space complexity is \(\mathcal{O}(n)\) as well.
\nt{The time complexity of \vocab{Regular Expressions} and \vocab{Stack Operations} for insertion and deletion are known to be \(\mathcal{O}(n)\) and \(O(1)\) respectively, so the time and space complexity of the algorithm remains at \(\mathcal{O}(n)\).}
\section{Limitations}
While the algorithm determines perfectly if the brackets within any given algebraic statement are balanced, it does not check if the statement itself is a properly formed algebraic statement. Furthermore, it does not check that brackets on two sides of a given equality are balanced, as it only checks for bracket placement relative to other brackets in the entire input string (i.e. \(([0]\{=\}2)\) will be evaluated as balanced).
\section{Testing}
Testing is handled by the |tests.py| file, which generates \(t\) input strings of up to length \(l\), of which \(\sfrac{n}{2}\) inputs are valid, and the other half are invalid. To generate valid inputs, the generator randomly selects an opening bracket or a closing bracket that matches the last opening bracket until reaching the halfway point of the string length, at which point it iteratively closes all the remaining open brackets. An example output of running the tests is shown in~\autoref{fig:qn2_testing}.
\begin{figure}[H]
	\caption{Test output}
	\centering
	\label[fig]{fig:qn2_testing}
	\includegraphics{Qn2_testing}
\end{figure}
\subsection{Invalid Inputs}
Invalid inputs are a superset of valid inputs, thus the selection of brackets to insert at any given point is expanded to include all invalid closing brackets as well. The generator then selects a random index \(i\) to insert random brackets until the max length is reached. Then, the generator checks if the number of opening brackets match the number of closing brackets for each type of bracket. If they match, a random index is selected again to either insert or remove a bracket. This ensures that we also deal with the case that the length of the input string is odd. The generator then provides the input string and whether the string is valid to a checker function, which compares the output of the developed algorithm with the validity of the input string. To run the tests, a user may run |python test.py --tests \{number of tests\} --length \{max length of input strings\}|. The output will show how many tests the algorithm passes, and what the generated input strings were for each test.
\section{Listings}
\subsection{Algorithm}
\begin{lstlisting}[language=Python]
	import re

	def main(statement:str):
		return is_balanced(statement)

	def is_balanced(statement:str) -> bool:
		bracket_pairing = {
			"{": "}",
			"[": "]",
			"(": ")"
		}
		# fast check
		statement = re.sub(r"[A-Za-z0-9\*\-\+\^\/\=]", "", statement)
		if len(statement) % 2 != 0: return False
		brackets = [bracket for bracket in bracket_pairing.keys()]\
			+ [bracket for bracket in bracket_pairing.values()]
		stack = [ ]
		for char in statement:
			if char in brackets:
				if char in bracket_pairing.keys():
					stack.append(char)
				else:
					try:
						if bracket_pairing[stack.pop()] != char:
							return False
					except IndexError:
						return False
		return len(stack) == 0

	if __name__ == "__main__":
		res = main(input("Enter an algebraic statement: "))
		print(res)
\end{lstlisting}
\subsection{Testing}
\begin{lstlisting}[language=Python]
	import argparse
	import random
	from main import is_balanced

	def test_is_balanced(iters: int, max_length:int=10):
		"""Tests the is_balanced function over a given number of iterations.

		Args:
			iters (int): number of iterations
		"""
		results = []
		for i in range(iters):
			statement, proper = statement_generator(random.randint(1, max_length))
			print(f"Test {i+1}:\t{statement}:", end=" ")
			res = is_balanced(statement)
			if res == proper:
				print(f"Passed ({res})")
			else:
				print(f"Failed: {res} (should be {proper})")
			results.append(res == proper)
		print(f"Passed {results.count(True)} out of {iters} tests")

	def statement_generator(length: int):
		"""Generates a random algebraic statement of a given length.

		Args:
			length (int): length of the statement

		Returns:
			str: random algebraic statement
		"""
		length //= 2
		bracket_pairing = {
			"{": "}",
			"[": "]",
			"(": ")"
		}
		brackets = [bracket for bracket in bracket_pairing.keys()]\
			+ [bracket for bracket in bracket_pairing.values()]
		ret = ""
		state = random.choice([True, False])
		ret += random.choice([bracket for bracket in bracket_pairing.keys()])
		stack = [ret[0]]
		for _ in range(length):
			if state:
				candidates = [b for b in bracket_pairing.keys()]
				if ret[-1] in bracket_pairing.keys():
					candidates += [bracket_pairing[ret[-1]]]
				ret += random.choice(candidates)
				if ret[-1] in bracket_pairing.values():
					stack.pop()
				else:
					stack.append(ret[-1])
			else:
				ret += random.choice(brackets)
		for _ in range(len(stack)):
			if state:
				ret += bracket_pairing[stack.pop()]
			else:
				ret += random.choice(brackets)
		if not state:
			n_additions = random.randint(0, length)
			insertion_index = random.randint(0, len(ret))
			additions = [random.choice(brackets) for _ in range(n_additions)]
			ret = ret[:insertion_index-1] + "".join(additions) + ret[insertion_index+1:len(ret)+1-n_additions]
			# count the number of bracket pairs
			bracket_counts = {(k, v): 0 for k, v in bracket_pairing.items()}
			for char in ret:
				for k, v in bracket_pairing.items():
					if char == k:
						bracket_counts[(k, v)] += 1
					elif char == v:
						bracket_counts[(k, v)] -= 1
			# if the statement is potentially balanced, either remove or add a random character.
			if all([count == 0 for count in bracket_counts.values()]):
				# remove a random character
				if len(ret) > 2:
					loc = random.randint(1, len(ret)-1)
					ret = ret[:loc] + ret[loc+1:]
				else:
					ret += random.choice(brackets)
		return (ret, state)

	def main(tests: int=1000, max_length:int=10):
		test_is_balanced(tests, max_length)

	if __name__ == "__main__":
		parser = argparse.ArgumentParser()
		parser.add_argument("-t", "--tests", type=int, default=1000, help="number of tests to run")
		parser.add_argument("-l", "--length", type=int, default=10, help="maximum length of the statement")
		args = parser.parse_args()
		main(args.tests, args.length)
\end{lstlisting}
\chapter{}
\section{Problem Statement}
Write an array-based implementation of the array list ADT that achieves \(\mathcal{O}(1)\) time for insertion and removals at the front and at the end of the array list. Your implementation should also provide for a \(\mathcal{O}(1)\) time |get(i)| method. Assume that overflow does not occur. Explain and justify why your implementation has achieved the stated time complexity requirements.
\section{Requirements/Specification}
The program creates an array list with functions to insert and remove items at the front and back of the list as well as a function |get(i)| to get the element in the list at index |i|.

The function |insertItem(int input, int position)| inserts an item into the list. The argument input will be the item and the argument position will decide where the item will be inserted into the list. If the position is 0, the item will be inserted at the front of the list. If the position is 1, the item will be inserted at the end of the list. For example, |insertItem(15, 1)| will insert the item |15| at the end of the list.

The function |removeItem(int position)| removes an item from the list. The argument position will decide whether the item will be removed from the start or from the end of the list. If the position is 0, the item at the start of the list will be removed. If the position is 1, the item at the end of the list will be removed. For example, |removeItem(0)| will remove the item at the start of the list.
\section{User Guide}
\section{Structure/Design}
The program starts by creating an array with a large size (e.g. |int arr[100];|) and variables start (e.g. |int start = 50;|) and end (e.g. |int end = 51;|) to represent the starting and ending index of the list respectively. The list will be initialised somewhere in the middle of the array with the start index and end index next to each other. The list is between the start and end index of the array which will then expand or contract from there depending on where the items are inserted or removed (at the front or at the back of the list).
\begin{figure}[H]
	\centering
	\caption{Initialising the array}
	\begin{tikzpicture}[MyStyle/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt}]
		\matrix (A) [matrix of math nodes, nodes={MyStyle, anchor=center}, column sep=-\pgflinewidth]{ \phantom{1} & \cdots & \phantom{1} & \phantom{1} & \phantom{1} & \phantom{1} & \phantom{1} & \phantom{1} & \phantom{1} & \phantom{1} & \phantom{1} & \cdots & \phantom{1} \\};
		\node[below=of A-1-7] (start) {start};
		\node[below=of A-1-8] (end) {end};
		\draw[->] (start.north) to (A-1-7.south);
		\draw[->] (end.north) to (A-1-8.south);
	\end{tikzpicture}
	\label{fig:qn3_init}
\end{figure}
To add an item at the start of the list, the start position of the array will first take in the value of the item, then the start index will shift left (i.e. |start--;|). Similarly, to add an item at the end of the list, the end position of the array will take in the value of the item, then the end index will shift right (i.e. |end++;|). Since the function does not need to iterate through the list to insert the items, the time complexity for inserting items is \(\mathcal{O}(1)\).

\begin{figure}[H]
	\centering
	\caption{Insertion}
	\begin{tikzpicture}[MyStyle/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt}]
		\matrix (A) [matrix of math nodes, nodes={MyStyle, anchor=center}, column sep=-\pgflinewidth]{ \phantom{1} & \cdots & \phantom{1} & \phantom{1} & \phantom{1} & \phantom{1} & 7 & \phantom{1} & \phantom{1} & \phantom{1} & \phantom{1} & \cdots & \phantom{1} \\};
		\node[below=of A-1-6] (start) {start};
		\node[below=of A-1-8] (end) {end};
		\draw[->] (start.north) to (A-1-6.south);
		\draw[->] (end.north) to (A-1-8.south);
	\end{tikzpicture}
	\label{fig:qn3_insert}
\end{figure}
Even though the problem statement assumes that overflow does not occur, safety measures were put in place to prevent overflowing. If the start index is at the start of the array (i.e. |start == 0|) or the end index is at the end of the array (i.e. |end == 99|), trying to add another item into the list will print “Overflow!”

To remove an item from the start of the list, the start index will simply shift right (i.e. |start++;|), and to remove an item from the end of the list, the end index will simply shift left (i.e. |end--;|). Since the function only shifts the start or end index when removing items and does not iterate through the list, the time complexity for removing items is \(\mathcal{O}(1)\).
\begin{figure}[H]
	\centering
	\caption{Removal of nodes}
	\begin{tikzpicture}[MyStyle/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt}]
		\matrix (A) [matrix of math nodes, nodes={MyStyle, anchor=center}, column sep=-\pgflinewidth]{ \phantom{1} & \cdots & \phantom{1} & \phantom{1} & 3 & 4 & 7 & 12 & 5 & 8 & \phantom{1} & \cdots & \phantom{1} \\};
		\node[below=of A-1-4] (start) {start};
		\node[below=of A-1-11] (end) {end};
		\draw[->] (start.north) to (A-1-4.south);
		\draw[->] (end.north) to (A-1-11.south);
		\draw[decorate, decoration={brace, amplitude=10pt, raise=5pt, mirror}](A-1-5.south west) to node[black, midway, below=15pt] {array} (A-1-10.south east);
		\matrix (B) [matrix of math nodes, nodes={MyStyle, anchor=center}, column sep=-\pgflinewidth, below=of A, yshift=-10pt]{ \phantom{1} & \cdots & \phantom{1} & \phantom{1} & 3 & 4 & 7 & 12 & 5 & 8 & \phantom{1} & \cdots & \phantom{1} \\};
		\node[below=of B-1-4] (start) {start};
		\node[below=of B-1-10] (end) {end};
		\draw[->] (start.north) to (B-1-4.south);
		\draw[->] (end.north) to (B-1-10.south);
		\draw[decorate, decoration={brace, amplitude=10pt, raise=5pt, mirror}](B-1-5.south west) to node[black, midway, below=15pt] {array} (B-1-9.south east);
		\draw[->] (A-1-1.south west) to [bend right=45] node[midway, left] {\texttt{\footnotesize removeItem()}} (B-1-1.north west);
		\matrix (C) [matrix of math nodes, nodes={MyStyle, anchor=center}, column sep=-\pgflinewidth, below=of B, yshift=-10pt]{ \phantom{1} & \cdots & \phantom{1} & \phantom{1} & 3 & 4 & 7 & 12 & 5 & 8 & \phantom{1} & \cdots & \phantom{1} \\};
		\node[below=of C-1-5] (start) {start};
		\node[below=of C-1-10] (end) {end};
		\draw[->] (start.north) to (C-1-5.south);
		\draw[->] (end.north) to (C-1-10.south);
		\draw[decorate, decoration={brace, amplitude=10pt, raise=5pt, mirror}](C-1-6.south west) to node[black, midway, below=15pt] {array} (C-1-9.south east);
		\draw[->] (B-1-1.south west) to [bend right=45] node[midway, left] {\texttt{\footnotesize removeItem(1)}} (C-1-1.north west);
	\end{tikzpicture}
	\label{fig:qn3_insert}
\end{figure}
The list is deemed empty when the start and end index are next to each other. When a function is called to remove another item while the list is empty, it will print ``List is empty!''.

To get the item at index |i| of the list, the function starts counting at the start of the list (i.e. |arr[start + 1]|) and returns the item at index i of the list (i.e. |arr[start + 1 + i]|). Since this function returns the item at the stated index and does not require iteration through the list, the time complexity for this function is \(\mathcal{O}(1)\).

\begin{figure}[H]
	\centering
	\caption{List access example (accessing index 4)}
	\begin{tikzpicture}[MyStyle/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt}]
		\matrix (A) [matrix of math nodes, nodes={MyStyle, anchor=center}, column sep=-\pgflinewidth]{ \phantom{1} & \cdots & \phantom{1} & \phantom{1} & 3 & 4 & 7 & 12 & 5 & 8 & \phantom{1} & \cdots & \phantom{1} \\};
		\node[below=of A-1-4] (start) {start};
		\node[below=of A-1-11] (end) {end};
		\draw[->] (start.north) to (A-1-4.south);
		\draw[->] (end.north) to (A-1-11.south);
		\draw[decorate, decoration={brace, amplitude=10pt, raise=5pt, mirror}](A-1-5.south west) to node[black, midway, below=15pt] {array} (A-1-10.south east);
		\matrix (B) [matrix of math nodes, nodes={minimum width=2em, minimum height=2em, outer sep=0pt, anchor=center, above of=A, yshift=15pt}, column sep=-\pgflinewidth]{ \phantom{1} & \phantom{\cdots} & \phantom{1} & \phantom{1} & 0 & 1 & 2 & 3 & 4 & 5 & \phantom{1} & \phantom{\cdots} & \phantom{1} \\};
		\node[left of=B-1-5] {list index:};
		\node[circle, draw] at (A-1-9) {};
		\node[circle, draw] at (B-1-9) {};
	\end{tikzpicture}
	\label{fig:qn3_access}
\end{figure}
\section{Limitations}
The limitation of this array list ADT is that it has a maximum size depending on the value used during initialization and has a finite number of items that can be added into the list. The function only stops the list from overflowing but it does not have a solution to overflowing (e.g. increasing the size of the array).
\section{Testing}
\section{Listings}
\chapter{}
\section{Problem Statement}
Write a recursive algorithm to check that a sentence is a palindrome (ignoring blanks, lower case and upper case differences, and punctuation marks, so that ``Madam, I'm Adam'' is accepted as a palindrome). Analyse the efficiency of your implementation and provided a detailed discussion of its time complexity.
\ex{}{Please enter a sentence: Madam, I'm Adam Check if ``Madam, I'm Adam'' is a palindrome: True}
\section{Requirements/Specification}
This program is supposed to compare the characters in the sentence. First and last, Second and second last etc. If it matches, it is a palindrome. Some assumptions/conditions would be ignoring blanks, lower case, upper case differences, and punctuation marks. Some assumptions/conditions would be ignoring blanks, lower case, upper case differences, and punctuation marks. Empty strings will be considered as a palindrome too.
\section{User Guide}
\begin{enumerate}
	\item Click on the ``Run'' button in the IDE to run the program with python. Alternatively, running |python <filename>.py| will run the program.
	\item Input a sentence when prompted in the command line interface.
	\item The resulting output will show whether the input sentence was a palindrome.
\end{enumerate}
\section{Structure/Design}
The design of the system is that it will remove all punctuations and black spaces in the string then change all uppercase characters to lowercase characters before passing through the |palindrome| function. After the system has recorded the new string, a function for |palindrome| and |isPalindrome| will run to check the string and determine whether it is a palindrome.

For the |palindrome| function, if there is only one character it will return |true|. If the first and last characters do not match, it will return |false|. For more than 2 characters, it will check the middle substring whether the characters match.

For the |isPalindrome| function, if it is an empty string, it will be considered a palindrome and return |true|.

The operation of removing punctuations and blanks, and converting the string to lowercase is \(\mathcal{O}(n)\), \(n\) being the length of the string. As it iterates through the function |palindrome|, it checks if the first and last characters match, hence the time complexity of this function is \(\mathcal{O}(n)\). The function |isPalindrome| checks if the string is empty, hence the time complexity of the entire algorithm is \(\mathcal{O}(n)\).

\section{Limitations}
It only works for ASCII characters and  may not be efficient for large strings as it may take a long time to execute. For testing the random generated string, we assume the string length to generate the code, hence the chance for a given string to be a palindrome is determined by how long its length is. True palindromes for randomly generated strings are very hard to get.
\section{Testing}
\section{Listings}
\chapter{}
\section{Problem Statement}
\section{Requirements/Specification}
\section{User Guide}
\section{Structure/Design}
\section{Limitations}
\section{Testing}
\section{Listings}
\end{document}
